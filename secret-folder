#!/bin/sh -e
# vim:se sw=2 ts=2 sts=2 et ai tw=78:
#
# This script creates a filesystem image file in which LUKS encrypted data is
# stored.  This is aimed to store sensitive data securely with remote host
# service rsync.net using rsync.  For other cloud services, rsync may need to
# be replaced with rclone command.
#
# To recover the last data, use rsync as:
# $ mkdir -p path/to
# $ cd path/to
# $ rsync -a de1234@de1234.rsync.net:rsync .
#
# ... or specifically for this disk image file with
# $ rsync -a de1234@de1234.rsync.net:rsync/secret.img .
#
# To recover the older backup data, use rsync as:
# $ rsync -a de1234@de1234.rsync.net:.zfs/snapshot/daily_2022-01-01 .
#
# For list of available older backups
# $ ssh de1234@de1234.rsync.net ls -lsa .zfs/snapshot
#
# All these require us to set up ssh keys.
#   https://www.rsync.net/resources/howto/ssh_keys.html
#
### VARIABLES (Edit this to adopt to the system) ###
HOME="$(eval echo ~)"
# disk image path
PATH_DISK="$HOME/rsync/secret.img"
# device mapper target name
DM_TARGET=secret
# mount path
PATH_MNT="$HOME/$DM_TARGET"
# set mode
ECHO="echo"
TSLEEP="0"
NEW="0"
MOUNT="0"
UPDATE="0"
KEEP="0"
SIZE_DISK="16G"
# Multi line string
TARGET_FILES="# Edit this to adopt to the system
# Files to backup
.bash_logout
.bashrc
.profile
.bash_aliases
.bash_fzf_completion
.bash_fzf_keybindings
.bashrc
.benrc
.caffrc
.debrc
.devscripts
.gbp.conf
.gitconfig
.quiltrc-dpkg
.reportbugrc
.sbuildrc
.shellcheckrc
.config/black
.config/flake8
.config/pylintrc
# directories to backup
Documents
bin
.ssh
.gnupg
.config/autostart
.config/systemd/user
.local/share/keyrings
"
while [ -n "$1" ]; do
  case "$1" in
    new)
      shift
      if [ -n "$1" ];then
        SIZE_DISK="$1"
        shift
      fi
      NEW="1"
      # overrides
      MOUNT="0"
      ECHO="echo"
      break
      ;;
    systemd)
      shift
      ECHO="systemd-cat -p 5 -t bss echo"
      TSLEEP="120"
      ;;
    mount)
      shift
      MOUNT="1"
      ;;
    update)
      shift
      MOUNT="1"
      UPDATE="1"
      ;;
    keep)
      shift
      MOUNT="1"
      KEEP="1"
      ;;
    *)
      echo "=== secret folder tool ==="
      echo "${0##*/} [new [size]|systemd|update|keep]"
      exit 0
      ;;
  esac
done

### FUNCTIONS ###
new_secret () {
  if ! secret-tool lookup LUKS "$PATH_DISK" >/dev/null ; then
    echo "I: Setup passphrase for LUKS: $PATH_DISK" >&2
    secret-tool store --label="LUKS $PATH_DISK" LUKS "$PATH_DISK"
  else
    echo "I: Passphrase for LUKS aleady stored: $PATH_DISK" >&2
  fi
  echo "I: create $SIZE_DISK image: $PATH_DISK" >&2
  fallocate -l "$SIZE_DISK" "$PATH_DISK"
  echo "I: create LUKS in $PATH_DISK" >&2
  secret-tool lookup LUKS "$PATH_DISK" | \
    cryptsetup luksFormat "$PATH_DISK" -
  echo "I: open LUKS as /dev/mapper/$DM_TARGET" >&2
  secret-tool lookup LUKS "$PATH_DISK" | \
    sudo cryptsetup open "$PATH_DISK" "$DM_TARGET" --type luks
  echo "I: create btrfs in /dev/mapper/$DM_TARGET" >&2
  sudo mkfs.btrfs "/dev/mapper/$DM_TARGET"
  echo "I: mount /dev/mapper/$DM_TARGET on $PATH_MNT"
  sudo mount "/dev/mapper/$DM_TARGET" "$PATH_MNT"
  echo "I: set $PATH_MNT to UID:GID=1000:1000" >&2
  sudo chown "1000:1000" "$PATH_MNT"
  {
    echo "!!! Don't write into ~/secret/ manually                 !!!"
    echo "!!! This should be accessed only by ~/bin/secret-folder !!!"
  } > "$PATH_MNT/DO_NOT_WRITE_IN_MANUALLY"
}

check_secret () {
  if [ ! -e "$PATH_DISK" ]; then
    $ECHO "E: disk image missing: $PATH_DISK"
    $ECHO "I: create disk image interactively as: ${0##*/} new [size]"
    exit 1
  fi
  # wait for 120s if run by systemd start up, otherwise no wait
  sleep $TSLEEP
}

mount_secret () {
  # let's mount
  if mount|grep -e "$PATH_MNT" >/dev/null; then
    $ECHO "I: skip mounting:   /dev/mapper/$DM_TARGET on $PATH_MNT"
    $ECHO "I: already mounted: $(mount|grep -e "$PATH_MNT"|sed 's/type.*$//')"
  else
    $ECHO "I: unlock LUKS disk image $PATH_DISK as /dev/mapper/$DM_TARGET"
    secret-tool lookup LUKS "$PATH_DISK" | \
      sudo cryptsetup open "$PATH_DISK" "$DM_TARGET" --type luks
    $ECHO "I: mount /dev/mapper/$DM_TARGET on $PATH_MNT"
    sudo mount "/dev/mapper/$DM_TARGET" "$PATH_MNT"
  fi
  $ECHO "I: disk image usage (size used avail use%): $(df -h "$PATH_MNT" \
    | grep "$PATH_MNT" \
    | sed -e 's/\s\s*/ /g' \
    | cut -d' ' -f 2-5)"
}

backup_secret () {
$ECHO "I: back up to $PATH_MNT"
while read -r F ; do
  D="$(dirname "$F")"
  if [ "$D" = "." ]; then
    D=""
  else
    D="$D/"
  fi
  if [ -f "$F" ]; then
    if [ -n "$D" ]; then
      mkdir -p "$PATH_MNT/$D"
    fi
    rsync -a "$HOME/$F" "$PATH_MNT/$D"
  elif [ -d "$F" ]; then
    mkdir -p "$PATH_MNT/$F"
    rsync -ax --del "$HOME/$F/" "$PATH_MNT/$F"
  else
    $ECHO "broken ${0##*/}: $F non-existing"
  fi
done
}

unmount_secret () {
  sync;sync;sync
  sudo umount "$PATH_MNT" || true
  sudo cryptsetup close "$DM_TARGET" || true
}

### MAIN ###

cd "$HOME"
mkdir -p "$PATH_MNT"

# mount ~/secret
if [ "$NEW" = "1" ]; then
  new_secret
fi
if [ "$MOUNT" = "1" ]; then
  check_secret
  mount_secret
fi
# backup secret files into ~/secret

if [ "$UPDATE" = "1" ]; then
  { echo "$TARGET_FILES" | grep -v "^#" - } | backup_secret
fi

if [ "$KEEP" != "1" ]; then
  # unmount ~/secret
  unmount_secret
fi

