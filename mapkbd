#!/usr/bin/python3
# vim:se tw=0 sts=4 ts=4 et ai:
"""
mapkbd -- map kbd event data tool

Copyright Â© 2022 Osamu Aoki

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA
"""
# For main
import argparse
import logging

# import locale
import os
import sys
import shutil

# import collections
# from operator import itemgetter
import time
import struct

# import datetime
# For test
from pprint import pprint

MIN_PYTHON = (3, 9)
if sys.version_info < MIN_PYTHON:
    sys.exit("Python %s.%s or later is required.\n" % MIN_PYTHON)

# Action code 32bits
# 0x00000000 - 0x000003FF normal key code (actually up to 0x2ff)
#               use 0x3FF as none.
# 0x00000400 - 0x00003FFF 8 bits Mod-tap specifier bit field
# 0x00004000 - 0x0000FFFF 2 bit (0,1,2,3 layer specifier)

#######################################################################
# common kbd event data constants and functions
#######################################################################
# Key type constants (with fake type X06-X0F etc.)
EV_TYPE = (
    "SYN",
    "KEY",
    "REL",
    "ABS",
    "MSC",
    "SW",
    "X06",
    "X07",
    "X08",
    "X09",
    "X0A",
    "X0B",
    "X0C",
    "X0D",
    "X0E",
    "X0F",
    "X10",
    "LED",
    "SND",
    "REP",
    "FF",
    "PWR",
    "FF_STATUS",
    "X18",
    "X19",
    "X1A",
    "X1B",
    "X1C",
    "X1D",
    "X1E",
)

EV_TYPE_DICT = {}
for ev_type, ev_type_string in enumerate(EV_TYPE):
    EV_TYPE_DICT[ev_type_string] = ev_type


def get_ev_type_string(ev_type):
    if ev_type < 0x1F:
        ev_type_string = EV_TYPE[ev_type]
    else:
        ev_type_string = "{:#x}".format(ev_type)
    return ev_type_string


def get_ev_type(ev_type_string):
    if ev_type_string in EV_TYPE_DICT:
        ev_type = EV_TYPE_DICT[ev_type_string]
    elif ev_type_string[:2].upper == "0X":
        ev_type = int(ev_type_string, 0)
    else:
        ev_type = 0xF00  # invalid type
    return ev_type


#######################################################################
# Key code (0-127) with fake KC_84
KEY_CODE = (
    "RESERVED",
    "ESC",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "0",
    "MINUS",
    "EQUAL",
    "BACKSPACE",
    "TAB",
    "Q",
    "W",
    "E",
    "R",
    "T",
    "Y",
    "U",
    "I",
    "O",
    "P",
    "LEFTBRACE",
    "RIGHTBRACE",
    "ENTER",
    "LEFTCTRL",
    "A",
    "S",
    "D",
    "F",
    "G",
    "H",
    "J",
    "K",
    "L",
    "SEMICOLON",
    "APOSTROPHE",
    "GRAVE",
    "LEFTSHIFT",
    "BACKSLASH",
    "Z",
    "X",
    "C",
    "V",
    "B",
    "N",
    "M",
    "COMMA",
    "DOT",
    "SLASH",
    "RIGHTSHIFT",
    "KPASTERISK",
    "LEFTALT",
    "SPACE",
    "CAPSLOCK",
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",
    "F8",
    "F9",
    "F10",
    "NUMLOCK",
    "SCROLLLOCK",
    "KP7",
    "KP8",
    "KP9",
    "KPMINUS",
    "KP4",
    "KP5",
    "KP6",
    "KPPLUS",
    "KP1",
    "KP2",
    "KP3",
    "KP0",
    "KPDOT",
    "KC_84",
    "ZENKAKUHANKAKU",
    "102ND",
    "F11",
    "F12",
    "RO",
    "KATAKANA",
    "HIRAGANA",
    "HENKAN",
    "KATAKANAHIRAGANA",
    "MUHENKAN",
    "KPJPCOMMA",
    "KPENTER",
    "RIGHTCTRL",
    "KPSLASH",
    "SYSRQ",
    "RIGHTALT",
    "LINEFEED",
    "HOME",
    "UP",
    "PAGEUP",
    "LEFT",
    "RIGHT",
    "END",
    "DOWN",
    "PAGEDOWN",
    "INSERT",
    "DELETE",
    "MACRO",
    "MUTE",
    "VOLUMEDOWN",
    "VOLUMEUP",
    "POWER",
    "KPEQUAL",
    "KPPLUSMINUS",
    "PAUSE",
    "SCALE",
    "KPCOMMA",
    "HANGEUL",
    "HANJA",
    "YEN",
    "LEFTMETA",
    "RIGHTMETA",
    "COMPOSE",  # KC_127
)


KEY_CODE_DICT = {}
for key_code, key_code_string in enumerate(KEY_CODE):
    KEY_CODE_DICT[key_code_string] = key_code


def get_key_code_string(key_code):
    if key_code < 128:
        key_code_string = KEY_CODE[key_code]
    elif key_code < 256:
        key_code_string = "KC_{}".format(key_code)
    else:
        key_code_string = "KC_{:#x}".format(key_code)
    return key_code_string


def get_key_code(key_code_string):
    if key_code_string in KEY_CODE_DICT:
        key_code = KEY_CODE_DICT[key_code_string]
    elif key_code_string[:3] == "KC_":
        key_code = int(key_code_string[:3], 0)
    else:
        key_code = 0xF00  # invalid type
    return key_code

#######################################################################
SYN_CODE = ("REPORT", "CONFIG", "MT_REPORT", "DROPPED")

SYN_CODE_DICT = {}
for syn_code, syn_code_string in enumerate(SYN_CODE):
    SYN_CODE_DICT[syn_code_string] = syn_code


def get_syn_code_string(syn_code):
    if syn_code < 4:
        syn_code_string = SYN_CODE[syn_code]
    else:
        syn_code_string = "{}".format(syn_code)
    return syn_code_string


def get_syn_code(syn_code_string):
    if syn_code_string in SYN_CODE_DICT:
        syn_code = SYN_CODE_DICT[syn_code_string]
    else:
        syn_code = int(syn_code_string, 0)  # invalid type
    return syn_code


def get_syn_value(syn_value_string):
    return int(syn_value_string, 0)


def get_syn_value_string(syn_value):
    return "{}".format(syn_value)


############################################################################
# Real key code is up to 0x2ff (10 bit wide)
# No need to have table for all key code.  1-127 (7 bit) is suffice
# action code = (action_type, action_value)
# If action_type == 0: action_value = keycode release
# If action_type == 1: action_value = keycode press
# If action_type == 2: action_value = keycode repeat
# If action_type == 4: mod_shift and action_value = keycode press
#

# so 0x1000 - 0x1fff (12 bits) are free
# Layer: 0, 1, 2, ... 7/15           = 3 or 4 bits
# Mod state: (L+R)(SFT+CTL+ALT+META) = 5 or 8 bits
# 0x400-0x4FF: 256 codes for internal use:
# Transparent: 0x400
# Opaque:      0x401

# fmt: off
# Blank key map
####    "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",         "",         "",         "",         "",
####    "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
####    "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
####    "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",                                  "",
####    "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",                                             "",
####    "",         "",         "",                              "",                                    "",         "",         "",                     "",         "",         "",
####                                                                                                                                                    "",         "",         ""
# define key positions

POS2ORIGINAL= (
        "ESC",      "F1",       "F2",       "F3",       "F4",       "F5",       "F6",       "F7",       "F8",       "F9",       "F10",      "F11",      "F12",      "HOME",     "END",      "INSERT",   "DELETE",
        "GRAVE",    "1",        "2",        "3",        "4",        "5",        "6",        "7",        "8",        "9",        "0",        "MINUS",    "EQUAL",                "BACKSPACE",
        "TAB",      "Q",        "W",        "E",        "R",        "T",        "Y",        "U",        "I",        "O",        "P",        "LEFTBRACE","RIGHTBRACE",           "BACKSLASH",
        "CAPSLOCK", "A",        "S",        "D",        "F",        "G",        "H",        "J",        "K",        "L",        "SEMICOLON","APOSTROPHE",                       "ENTER",
        "LEFTSHIFT","Z",        "X",        "C",        "V",        "B",        "N",        "M",        "COMMA",    "DOT",      "SLASH",                                        "RIGHTSHIFT",
        "LEFTCTRL", "LEFTMETA", "LEFTALT",                       "SPACE",                               "RIGHTALT", "SYSRQ",    "RIGHTCTRL",            "PAGEUP",   "UP",       "PAGEDOWN",
                                                                                                                                                        "LEFT",     "DOWN",     "RIGHT"
        )

# fmt: on
LEN_POS2ORIGINAL = len(POS2ORIGINAL)

# print("=== SORT BY POS ===")
# for pos, kcs in enumerate(POS2ORIGINAL):
#     print("ORIGINAL[KC={}]=POS_{},  # {}".format(get_key_code(kcs), pos, kcs))

# print("=== SORT BY KC ===")
# for kc, pos in sorted([(get_key_code(kcs), pos) for pos, kcs in enumerate(POS2ORIGINAL)]):
#     print("ORIGINAL[KC={}]=POS_{},  # {}".format(kc, pos, get_key_code_string(kc)))
# exit(0)
ORIG2POS = {}
for kc, pos in sorted(
    [(get_key_code(kcs), pos) for pos, kcs in enumerate(POS2ORIGINAL)]
):
    ORIG2POS[kc] = pos

# for kc in ORIG2POS:
#     print("MAP[KC={}]=POS_{},  # {}".format(kc, ORIG2POS[kc], get_key_code_string(kc)))


def get_pos(kc):
    if kc in ORIG2POS:
        pos = ORIG2POS[kc]
    else:
        pos = LEN_POS2ORIGINAL
    return


# fmt: off
# Mapped key
MAP_KEY_STRING = (
        (
        "ESC",      "F1",       "F2",       "F3",       "F4",       "F5",       "F6",       "F7",       "F8",       "F9",       "F10",      "F11",      "F12",      "HOME",     "END",      "INSERT",   "DELETE",
        "GRAVE",    "1",        "2",        "3",        "4",        "5",        "6",        "7",        "8",        "9",        "0",        "MINUS",    "EQUAL",                "BACKSPACE",
        "TAB",      "Q",        "W",        "E",        "R",        "T",        "Y",        "U",        "I",        "O",        "P",        "LEFTBRACE","RIGHTBRACE",           "BACKSLASH",
        "ESC",      "A",        "S",        "D",        "F",        "G",        "H",        "J",        "K",        "L",        "SEMICOLON","APOSTROPHE",                       "ENTER",
        "MUTE",     "Z",        "X",        "C",        "V",        "B",        "N",        "M",        "COMMA",    "DOT",      "SLASH",                                        "RIGHTSHIFT",
        "LEFTCTRL", "LEFTMETA", "LEFTALT",                       "SPACE",                               "RIGHTALT", "SYSRQ",    "RIGHTCTRL",            "PAGEUP",   "UP",       "PAGEDOWN",
                                                                                                                                                        "LEFT",     "DOWN",     "RIGHT"
        ),
        (
        "ESC",      "F1",       "F2",       "F3",       "F4",       "F5",       "F6",       "F7",       "F8",       "F9",       "F10",      "F11",      "F12",      "HOME",     "END",      "INSERT",   "DELETE",
        "GRAVE",    "1",        "2",        "3",        "4",        "5",        "6",        "7",        "8",        "9",        "0",        "MINUS",    "EQUAL",                "BACKSPACE",
        "F11",      "F1",       "F2",       "F3",       "F4",       "F5",       "F6",       "F7",       "F8",       "F9",       "F10",      "F12",      "BACKSPACE",            "BACKSLASH",
        "ESC",      "1",        "2",        "3",        "4",        "5",        "6",        "7",        "8",        "9",        "0",        "ENTER",                            "ENTER",
        "APP",      "GRAVE",    "",         "",         "MINUS",    "EQUAL",    "LEFTBRACE","RIGHTBRACE","BACKSLASH","",        "APOSTROPHE",                                   "SYSRQ",
        "LEFTCTRL", "LEFTMETA", "LEFTALT",                       "SPACE",                               "RIGHTALT", "SYSRQ",    "RIGHTCTRL",            "PAGEUP",   "UP",       "PAGEDOWN",
                                                                                                                                                        "LEFT",     "DOWN",     "RIGHT"
        ),
        (
        "ESC",      "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",         "",         "",         "",         "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
        "ESC",      "",         "",         "",         "",         "",         "INSERT",   "PAGEUP",   "UP",       "PAGEDOWN", "DELETE",  "",          "",                     "",
        "",         "LEFTSHIFT","LEFTCTRL", "LEFTALT",  "LEFTMETA", "",         "HOME",     "LEFT",     "DOWN",     "RIGHT",    "END",     "ENTER",                             "ENTER",
        "",         "",         "",         "",         "",         "",         "",         "",         "TAB",      "",         "",                                             "",
        "",         "",         "",                              "",                                    "",         "",         "",                     "",         "",         "",
                                                                                                                                                        "",         "",         ""
        ),
        )


# This is for action type
MAP_ACTION_STRING = (
        (
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",         "",         "",         "",         "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
        "MT_LCTL",  "MT_LSFT",  "MT_LCTL",  "MT_LALT",  "MT_LMETA", "MT_RALT",  "MT_RALT",  "MT_LMETA", "MT_LALT",  "MT_RCTL",  "MT_RSFT", "",                                  "",
        "MT_LSFT",  "",         "",         "",         "LT_2",     "",         "",         "",         "",         "",         "",                                             "",
        "",         "",         "",                              "LT_1",                                "",         "",         "",                     "",         "",         "",
                                                                                                                                                        "",         "",         ""
        ),
        (
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",         "",         "",         "",         "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
        "",         "MT_LSFT",  "MT_LCTL",  "MT_LALT",  "MT_LMETA", "MT_RALT",  "MT_RALT",  "MT_LMETA", "MT_LALT",  "MT_RCTL",  "MT_RSFT", "",                                  "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",                                             "",
        "",         "",         "",                              "",                                    "",         "",         "",                     "",         "",         "",
                                                                                                                                                        "",         "",         ""
        ),
        (
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",         "",         "",         "",         "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",                                  "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",                                             "",
        "",         "",         "",                              "",                                    "",         "",         "",                     "",         "",         "",
                                                                                                                                                        "",         "",         ""
        ),
        )


# fmt: on

# Sanity check
NK = len(MAP_KEY_STRING)
NA = len(MAP_ACTION_STRING)
if NK != NA:
    print("E: wrong number of layers in string based data: (key={}) != (action={})".format(NK, NA))
    exit(1)
N = NK

for l in range(N):
    if len(MAP_KEY_STRING[l]) != LEN_POS2ORIGINAL:
        print(
            "E: wrong layers: (TAP={}) != (ORIGINAL={})".format(
                len(MAP_KEY_STRING[l]), LEN_POS2ORIGINAL
            )
        )
        exit(1)
    if len(MAP_ACTION_STRING[l]) != LEN_POS2ORIGINAL:
        print(
            "E: wrong layers: (HOLD={}) != (ORIGINAL={})".format(
                len(MAP_ACTION_STRING[l]), LEN_POS2ORIGINAL
            )
        )
        exit(1)

print("I: sane situation: {} layers {} positions".format(N, LEN_POS2ORIGINAL))

MAP = []
for l in range(N):
    L = []
    for pos in range(LEN_POS2ORIGINAL):
        L.append(get_keycode(MAP_KEY_STRING[l][pos]), get_actioncode(MAP_ACTION_STRING[l][pos]))
    MAP.append(L)

def get_action(kc, layer):
    pos = get_pos(kc)
    if pos < LEN_POS2ORIGINAL:
        (kc_mapped, action) = MAP[layer][pos]
    else:
        kc_mapped = None
        action = None
    return (kc_mapped, action)

#######################################################################
MSC=get_ev_type("MSC")
SCAN=get_msc_code("SCAN")

KEY=get_ev_type("KEY")
DOWN = 0
UP = 1
REPEAT = 2

SYN = get_ev_type("SYN")
REPORT = get_syn_code("REPORT")

YETTAP = 0
TAP = 1
HOLD = 2

EVDEV_EVENT = struct.Struct("llHHI")

def event_in():
    data = sys.stdin.buffer.read(EVDEV_EVENT.size)
    return EVDEV_EVENT.unpack(data)
    # return (t_s, t_us, ev_type, ev_code, ev_value)

def event_out(t_s, t_us, t_key, ev_type, ev_code, ev_value):
    event = EVDEV_EVENT.pack(t_s, t_us, ev_type, ev_code, ev_value)
    return sys.stdout.buffer.write(event)

class key_event_set:
    # Keyboard event class
    def __init__(self):
        self.time = None
        self.utime = None
        self.scan = None
        self.code = None
        self.value = None
        self.syn = None
        self.taphold = YETTAP
        return

    def newtime(self, time, utime):
        if self.time is not None or self.utime is not None:
            print("E: duplicated time {}.{:03d}".format(time, utime))
        self.time = time
        self.utime = utime

    def checktime(self, time, utime):
        if self.time is None or self.utime is None:
            print("E: Missing time {}.{:03d}".format(time, utime))
        if self.time != time or self.utime != utime:
            print(
                "E: Different time {}.{:03d} != {}.{:03d}".format(
                    self.time, self.utime, time, utime
                )
            )

    def newscan(self, scan):
        if self.scan is not None:
            print("E: duplicated scan code")
        self.scan = scan

    def newcode(self, code, value):
        if self.code is not None or self.value is not None:
            print("E: duplicated key code and value set")
        self.code = code
        self.value = value

    def newsyn(self, syn):
        if self.syn is not None:
            print("E: duplicated syn report value")
        if syn == 0 and self.scan is not None:
            pass
        else:
            print(
                "E: Unexpected syn report value {} for with scan code {}".format(
                    syn, self.scan
                )
            )
        if syn == 1 and self.scan is None:
            pass
        else:
            print("E: Unexpected syn report value {} for no scan code".format(syn))
        self.syn = syn

    def output(self):
        # output set of 2-3 events for a key
        if self.syn == 0:
            event_out(key.time, key.utime, MSC, SCAN, key.scan)
        event_out(key.time, key.utime, KEY, key.code, key.value)
        event_out(key.time, key.utime, SYN, REPORT, key.syn)


def map(args):
    nevents = 0  # 0, 1, [2]
    layer = 0  # 0, 1
    state = 0  # 0:D 1:U, 2:R 3:H (DU of other during D)
    input_queue = []
    output_queue = []
    while True:
        (t_s, t_us, ev_type, ev_code, ev_value) = get_event_in()
        if nevents == 0:
            key = key_event_set()
            key.newtime(t_s, t_us)
        else:
            key.checktime(t_s, t_us)
        #
        if ev_type == MSC and ev_code == SCAN:
            key.newscan(ev_value)
            nevents = +1
        elif ev_type == KEY and ev_code < 128:
            key.newcode(ev_code, ev_value)
            nevents = +1
        elif ev_type == SYN and ev_code == REPORT:
            key.newsyn(ev_value)
            if key.value == DOWN:
                # just place it in the queue as .taphold = YETTAP
                input_queue.append(key)
            elif key.value == REPEAT:
                for xkey in input_queue:
                    if key.code == xkey.code and key.value == DOWN:
                        if xkey.taphold == YETTAP:
                            xkey.taphold = HOLD
                key.taphold = HOLD
                input_queue.append(key)
            else:  # key.value == UP:
                for xkey in input_queue:
                    if key.code == xkey.code:
                        if xkey.taphold == YETTAP:
                            xkey.taphold = TAP
                if key.taphold == YETTAP:
                    key.taphold = TAP
                    found = 0
                    for xkey in reversed(input_queue):
                        # any key after the last key.code
                        if key.code == xkey.code:
                            found = 1
                        if found == 1:
                            if xkey.taphold == YETTAP:
                                xkey.taphold = HOLD
                # if layer-mod released
                input_queue.append(key)
                for xkey in input_queue:
                    if xkey.taphold = YETTAP:
                        break
                    else:
                        # Process
                        pass
                        #output_queue.extend(xkey.process(0)) # layer ???
                        #layer = xkey.update_layer()
                        #loop over buffer
                # shorten queue
                sys.stdout.buffer.flush()


                key.state = HOLD

            # if down
            #  push event_queue.append(key.process())
            # if rep
            # check event_queue.append(key.process())
            # if up
            # pop event_queue.append(key.process())
            nevents = 0
        else:
            pass  # ignore strange
    return


#         if ev_type == get_ev_type("KEY") and ev_code == get_key_code("Q") and ev_value == get_key_value("DOWN"):
#             event_queue.append((t_key-1, ev_type, get_key_code("LEFTSHIFT"), get_key_value("DOWN")))
#             event_queue.append((t_key-1, get_ev_type("SYN"), get_syn_code("REPORT"), 0))
#             event_queue.append((t_key, ev_type, get_key_code("Z"), get_key_value("DOWN")))
#         elif ev_type == get_ev_type("KEY") and ev_code == get_key_code("Q") and ev_value == get_key_value("UP"):
#             event_queue.append((t_key-1, ev_type, get_key_code("Z"), get_key_value("DOWN")))
#             event_queue.append((t_key-1, get_ev_type("SYN"), get_syn_code("REPORT"), 0))
#             event_queue.append((t_key, ev_type, get_key_code("LEFTSHIFT"), get_key_value("UP")))
#         else:
#             event_queue.append((t_key,ev_type, ev_code, ev_value))
#             for event in event_queue:
#                 t_key, ev_type, ev_code, ev_value = event
#                 event_out(t_key, ev_type, ev_code, ev_value, args)
#             event_queue = []
#######################################################################
# main: parse commandline parser
#######################################################################
def main():
    parser = argparse.ArgumentParser(
        description="""\
A collection of python scripts to play with evdev events.

version: {}

copyright 2022 Osamu Aoki <osamu@debian.org>

license: GPL 2.0+

See See https://github.com/osamuaoki/{}
""".format(
            "0.1", "osamu-utils"
        ),
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help="Set output to be more verbose",
    )
    parser.add_argument(
        "-q", "--quiet", action="count", default=0, help="Set output to be more quieter"
    )
    parser.add_argument(
        "-c",
        "--command",
        action="store",
        default="T",
        help="Command mode (TextDump, Passthrough, Mangle)",
    )
    parser.add_argument(
        "-m",
        "--no-misc",
        action="store_true",
        default=False,
        help="No mis. events",
    )
    parser.add_argument(
        "-k",
        "--key-only",
        action="store_true",
        default=False,
        help="Only key events",
    )
    parser.add_argument(
        "-t",
        "--time-format",
        action="store",
        default="D",
        help="Time format (abs, this, del)",
    )
    parser.add_argument(
        "-o",
        "--output",
        action="store",
        default="T",
        help="Output format (tsv-csv, yaml)",
    )
    parser.add_argument(
        "-s",
        "--state",
        action="store",
        default="official",
        help="state press/release/repeat indicators (official, utf-8, ascii)",
    )
    args = parser.parse_args()
    if args.state.upper()[0] == "U":  # UTF-8
        args.key_value_string_type = 1
    elif args.state.upper()[0] == "O":  # Official names
        args.key_value_string_type = 0
    else:
        args.key_value_string_type = 2
    #######################################################################
    # Update variables with sanitization
    #######################################################################
    #    CRITICAL 50
    #    ERROR 40
    #    WARNING 30
    #    INFO 20
    #    DEBUG 10
    logging.root.level = 10 * (args.quiet - args.verbose) + 40
    map(args)
    return


#######################################################################
# Test code
#######################################################################
if __name__ == "__main__":
    main()
