#!/usr/bin/python3
# vim:se tw=0 sts=4 ts=4 et ai:
"""
mapkbd -- map kbd event data tool

Copyright Â© 2022 Osamu Aoki

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA
"""
# For main
import argparse
import logging

# import locale
import os
import sys
import shutil

# import collections
# from operator import itemgetter
import time
import struct

# import datetime
# For test
from pprint import pprint

MIN_PYTHON = (3, 9)

INPUT_EVENT = struct.Struct("llHHI")

if sys.version_info < MIN_PYTHON:
    sys.exit("Python %s.%s or later is required.\n" % MIN_PYTHON)

#######################################################################
# Key code (unique) with fake KC_84
KEY_CODE = (
    "RESERVED",
    "ESC",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "0",
    "MINUS",
    "EQUAL",
    "BACKSPACE",
    "TAB",
    "Q",
    "W",
    "E",
    "R",
    "T",
    "Y",
    "U",
    "I",
    "O",
    "P",
    "LEFTBRACE",
    "RIGHTBRACE",
    "ENTER",
    "LEFTCTRL",
    "A",
    "S",
    "D",
    "F",
    "G",
    "H",
    "J",
    "K",
    "L",
    "SEMICOLON",
    "APOSTROPHE",
    "GRAVE",
    "LEFTSHIFT",
    "BACKSLASH",
    "Z",
    "X",
    "C",
    "V",
    "B",
    "N",
    "M",
    "COMMA",
    "DOT",
    "SLASH",
    "RIGHTSHIFT",
    "KPASTERISK",
    "LEFTALT",
    "SPACE",
    "CAPSLOCK",
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",
    "F8",
    "F9",
    "F10",
    "NUMLOCK",
    "SCROLLLOCK",
    "KP7",
    "KP8",
    "KP9",
    "KPMINUS",
    "KP4",
    "KP5",
    "KP6",
    "KPPLUS",
    "KP1",
    "KP2",
    "KP3",
    "KP0",
    "KPDOT",
    "KC_84",
    "ZENKAKUHANKAKU",
    "102ND",
    "F11",
    "F12",
    "RO",
    "KATAKANA",
    "HIRAGANA",
    "HENKAN",
    "KATAKANAHIRAGANA",
    "MUHENKAN",
    "KPJPCOMMA",
    "KPENTER",
    "RIGHTCTRL",
    "KPSLASH",
    "SYSRQ",
    "RIGHTALT",
    "LINEFEED",
    "HOME",
    "UP",
    "PAGEUP",
    "LEFT",
    "RIGHT",
    "END",
    "DOWN",
    "PAGEDOWN",
    "INSERT",
    "DELETE",
    "MACRO",
    "MUTE",
    "VOLUMEDOWN",
    "VOLUMEUP",
    "POWER",
    "KPEQUAL",
    "KPPLUSMINUS",
    "PAUSE",
    "SCALE",
    "KPCOMMA",
    "HANGEUL",
    "HANJA",
    "YEN",
    "LEFTMETA",
    "RIGHTMETA",
    "COMPOSE",
)


KEY_CODE_DICT = {}
for key_code, key_code_string in enumerate(KEY_CODE):
    KEY_CODE_DICT[key_code_string] = key_code


def get_key_code_string(key_code):
    if key_code < 128:
        key_code_string = KEY_CODE[key_code]
    elif key_code < 256:
        key_code_string = "KC_{}".format(key_code)
    else:
        key_code_string = "KC_{:#x}".format(key_code)
    return key_code_string


def get_key_code(key_code_string):
    if key_code_string in KEY_CODE_DICT:
        key_code = KEY_CODE_DICT[key_code_string]
    elif key_code_string[:3] == "KC_":
        key_code = int(key_code_string[:3], 0)
    else:
        key_code = 0xF00  # invalid type
    return key_code


############################################################################
# Real key code is up to 0x2ff (10 bit wide)
# No need to have table for all key code.  1-127 (7 bit) is suffice
# action code = (action_type, action_value)
# If action_type == 0: action_value = keycode release
# If action_type == 1: action_value = keycode press
# If action_type == 2: action_value = keycode repeat
# If action_type == 4: mod_shift and action_value = keycode press
#

# so 0x1000 - 0x1fff (12 bits) are free
# Layer: 0, 1, 2, ... 7/15           = 3 or 4 bits
# Mod state: (L+R)(SFT+CTL+ALT+META) = 5 or 8 bits
# 0x400-0x4FF: 256 codes for internal use:
# Transparent: 0x400
# Opaque:      0x401

# fmt: off
# Blank key map
####    "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",         "",         "",         "",         "",
####    "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
####    "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
####    "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",                                  "",
####    "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",                                             "",
####    "",         "",         "",                              "",                                    "",         "",         "",                     "",         "",         "",
####                                                                                                                                                    "",         "",         ""
# define key positions

POS2ORIGINAL= (
        "ESC",      "F1",       "F2",       "F3",       "F4",       "F5",       "F6",       "F7",       "F8",       "F9",       "F10",      "F11",      "F12",      "HOME",     "END",      "INSERT",   "DELETE",
        "GRAVE",    "1",        "2",        "3",        "4",        "5",        "6",        "7",        "8",        "9",        "0",        "MINUS",    "EQUAL",                "BACKSPACE",
        "TAB",      "Q",        "W",        "E",        "R",        "T",        "Y",        "U",        "I",        "O",        "P",        "LEFTBRACE","RIGHTBRACE",           "BACKSLASH",
        "CAPSLOCK", "A",        "S",        "D",        "F",        "G",        "H",        "J",        "K",        "L",        "SEMICOLON","APOSTROPHE",                       "ENTER",
        "LEFTSHIFT","Z",        "X",        "C",        "V",        "B",        "N",        "M",        "COMMA",    "DOT",      "SLASH",                                        "RIGHTSHIFT",
        "LEFTCTRL", "LEFTMETA", "LEFTALT",                       "SPACE",                               "RIGHTALT", "SYSRQ",    "RIGHTCTRL",            "PAGEUP",   "UP",       "PAGEDOWN",
                                                                                                                                                        "LEFT",     "DOWN",     "RIGHT"
        )

# fmt: on
LEN_POS2ORIGINAL=len(POS2ORIGINAL)

# print("=== SORT BY POS ===")
# for pos, kcs in enumerate(POS2ORIGINAL):
#     print("ORIGINAL[KC={}]=POS_{},  # {}".format(get_key_code(kcs), pos, kcs))

# print("=== SORT BY KC ===")
# for kc, pos in sorted([(get_key_code(kcs), pos) for pos, kcs in enumerate(POS2ORIGINAL)]):
#     print("ORIGINAL[KC={}]=POS_{},  # {}".format(kc, pos, get_key_code_string(kc)))
# exit(0)
ORIG2POS={}
for kc, pos in sorted([(get_key_code(kcs), pos) for pos, kcs in enumerate(POS2ORIGINAL)]):
    ORIG2POS[kc] = pos

for kc in ORIG2POS:
    print("MAP[KC={}]=POS_{},  # {}".format(kc, ORIG2POS[kc], get_key_code_string(kc)))

def get_pos(kc):
    if kc in ORIG2POS:
        pos = ORIG2POS[kc]
    else:
        pos = LEN_POS2ORIGINAL
    return

# fmt: off
# Mapped keys for tap (and w hold="")
MAP_TAP= (
        (
        "ESC",      "F1",       "F2",       "F3",       "F4",       "F5",       "F6",       "F7",       "F8",       "F9",       "F10",      "F11",      "F12",      "HOME",     "END",      "INSERT",   "DELETE",
        "GRAVE",    "1",        "2",        "3",        "4",        "5",        "6",        "7",        "8",        "9",        "0",        "MINUS",    "EQUAL",                "BACKSPACE",
        "TAB",      "Q",        "W",        "E",        "R",        "T",        "Y",        "U",        "I",        "O",        "P",        "LEFTBRACE","RIGHTBRACE",           "BACKSLASH",
        "ESC",      "A",        "S",        "D",        "F",        "G",        "H",        "J",        "K",        "L",        "SEMICOLON","APOSTROPHE",                       "ENTER",
        "MUTE",     "Z",        "X",        "C",        "V",        "B",        "N",        "M",        "COMMA",    "DOT",      "SLASH",                                        "RIGHTSHIFT",
        "LEFTCTRL", "LEFTMETA", "LEFTALT",                       "SPACE",                               "RIGHTALT", "SYSRQ",    "RIGHTCTRL",            "PAGEUP",   "UP",       "PAGEDOWN",
                                                                                                                                                        "LEFT",     "DOWN",     "RIGHT"
        ),
        (
        "ESC",      "F1",       "F2",       "F3",       "F4",       "F5",       "F6",       "F7",       "F8",       "F9",       "F10",      "F11",      "F12",      "HOME",     "END",      "INSERT",   "DELETE",
        "GRAVE",    "1",        "2",        "3",        "4",        "5",        "6",        "7",        "8",        "9",        "0",        "MINUS",    "EQUAL",                "BACKSPACE",
        "F11",      "F1",       "F2",       "F3",       "F4",       "F5",       "F6",       "F7",       "F8",       "F9",       "F10",      "F12",      "BACKSPACE",            "BACKSLASH",
        "ESC",      "1",        "2",        "3",        "4",        "5",        "6",        "7",        "8",        "9",        "0",        "ENTER",                            "ENTER",
        "APP",      "GRAVE",    "",         "",         "MINUS",    "EQUAL",    "LEFTBRACE","RIGHTBRACE","BACKSLASH","",        "APOSTROPHE",                                   "SYSRQ",
        "LEFTCTRL", "LEFTMETA", "LEFTALT",                       "SPACE",                               "RIGHTALT", "SYSRQ",    "RIGHTCTRL",            "PAGEUP",   "UP",       "PAGEDOWN",
                                                                                                                                                        "LEFT",     "DOWN",     "RIGHT"
        ),
        (
        "ESC",      "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",         "",         "",         "",         "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
        "ESC",      "",         "",         "",         "",         "",         "INSERT",   "PAGEUP",   "UP",       "PAGEDOWN", "DELETE",  "",          "",                     "",
        "",         "LEFTSHIFT","LEFTCTRL", "LEFTALT",  "LEFTMETA", "",         "HOME",     "LEFT",     "DOWN",     "RIGHT",    "END",     "ENTER",                             "ENTER",
        "",         "",         "",         "",         "",         "",         "",         "",         "TAB",      "",         "",                                             "",
        "",         "",         "",                              "",                                    "",         "",         "",                     "",         "",         "",
                                                                                                                                                        "",         "",         ""
        ),
        )

# This is for hold
MAP_HOLD= (
        (
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",         "",         "",         "",         "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
        "MT_LCTL",  "MT_LSFT",  "MT_LCTL",  "MT_LALT",  "MT_LMETA", "MT_RALT",  "MT_RALT",  "MT_LMETA", "MT_LALT",  "MT_RCTL",  "MT_RSFT", "",                                  "",
        "MT_LSFT",  "",         "",         "",         "LT_2",     "",         "",         "",         "",         "",         "",                                             "",
        "",         "",         "",                              "LT_1",                                "",         "",         "",                     "",         "",         "",
                                                                                                                                                        "",         "",         ""
        ),
        (
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",         "",         "",         "",         "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
        "",         "MT_LSFT",  "MT_LCTL",  "MT_LALT",  "MT_LMETA", "MT_RALT",  "MT_RALT",  "MT_LMETA", "MT_LALT",  "MT_RCTL",  "MT_RSFT", "",                                  "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",                                             "",
        "",         "",         "",                              "",                                    "",         "",         "",                     "",         "",         "",
                                                                                                                                                        "",         "",         ""
        ),
        (
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",         "",         "",         "",         "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",          "",                     "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",        "",                                  "",
        "",         "",         "",         "",         "",         "",         "",         "",         "",         "",         "",                                             "",
        "",         "",         "",                              "",                                    "",         "",         "",                     "",         "",         "",
                                                                                                                                                        "",         "",         ""
        ),
        )
# fmt: on

# Sanity check
NLAYERST = len(MAP_TAP)
NLAYERSH = len(MAP_HOLD)
if NLAYERST !=  NLAYERSH:
    print("E: wrong layers: (TAP={}) != (HOLD={})".format(NLAYERST,  NLAYERSH))
    exit (1)
else:
    print("I: good layers: (TAP={}) == (HOLD={})".format(NLAYERST,  NLAYERSH))
NLAYERS = NLAYERST
for l in range(NLAYERS):
    if len(MAP_TAP[l]) != LEN_POS2ORIGINAL:
        print("E: wrong layers: (TAP={}) != (ORIGINAL={})".format(len(MAP_TAP[l]), LEN_POS2ORIGINAL))
        exit (1)
    if len(MAP_HOLD[l]) != LEN_POS2ORIGINAL:
        print("E: wrong layers: (HOLD={}) != (ORIGINAL={})".format(len(MAP_HOLD[l]), LEN_POS2ORIGINAL))
        exit (1)

print("I: sane layers")

def get_action(kc, later):
    pos = get_pos(kc)
    if pos < LEN_POS2ORIGINAL:
        tap = MAP_TAP[layer][pos]
        hold = MAP_HOLD[layer][pos]
    else:
        tap = None
        hold = None
    return (tap, hold)

class key_event_set():
    # Keyboard event class
    def __init__(self):
        self.time = None
        self.utime = None
        self.scan = None
        self.code = None
        self.value = None
        self.syn = None
        return
    def newtime(self, time, utime):
        if self.time is not None or self.utime is not None:
            print("E: duplicated time {}.{:03d}".format(time, utime))
        self.time = time
        self.utime = utime
    def checktime(self, time, utime):
        if self.time is None or self.utime is None:
            print("E: Missing time {}.{:03d}".format(time, utime))
        if self.time != time or self.utime != utime:
            print("E: Different time {}.{:03d} != {}.{:03d}".format(self.time, self.utime, time, utime))
    def newscan(self, scan):
        if self.scan is not None:
            print("E: duplicated scan code")
        self.scan = scan
    def newcode(self, code, value):
        if self.code is not None or self.value is not None:
            print("E: duplicated key code and value set")
        self.code = code
        self.value = value
    def newsyn(self, syn):
        if self.syn is not None:
            print("E: duplicated syn report value")
        if syn == 0 and self.scan is not None:
            pass
        else:
            print("E: Unexpected syn report value {} for with scan code {}".format(syn, self.scan))
        if syn == 1 and self.scan is None:
            pass
        else:
            print("E: Unexpected syn report value {} for no scan code".format(syn))
        self.syn = syn
    def process(self):
        (tap, hold) = get_action()

        # process key and return action sequence
        pass 



def map(args):
    nevents = 0  # 0, 1, [2]
    layer = 0  # 0, 1
    state = 0  # 0:D 1:U, 2:R 3:H (DU of other during D)
    event_queue = []
    while True:
        data = sys.stdin.buffer.read(INPUT_EVENT.size)
        (t_s, t_us, ev_type, ev_code, ev_value) = INPUT_EVENT.unpack(data)
        if nevents == 0:
            key = key_event_set()
            key.newtime(t_s, t_us)
        else:
            key.checktime(t_s, t_us)
        #
        if ev_type == get_ev_type("MSC") and ev_code == get_msc_code("SCAN"):
            key.newscan(ev_value)
            nevents =+ 1
        elif ev_type == get_ev_type("KEY") and ev_code < 128:
            key.newcode(ev_code, ev_value)
            nevents =+ 1
        elif ev_type == get_ev_type("SYN") and ev_code == get_syn_code("REPORT"):
            key.newsyn(ev_value)
            # if down
            #  push event_queue.append(key.process())
            # if rep
            # check event_queue.append(key.process())
            # if up
            # pop event_queue.append(key.process())
            nevents = 0
        else:
            pass # ignore strange
    return


#         if ev_type == get_ev_type("KEY") and ev_code == get_key_code("Q") and ev_value == get_key_value("DOWN"):
#             event_queue.append((t_key-1, ev_type, get_key_code("LEFTSHIFT"), get_key_value("DOWN")))
#             event_queue.append((t_key-1, get_ev_type("SYN"), get_syn_code("REPORT"), 0))
#             event_queue.append((t_key, ev_type, get_key_code("Z"), get_key_value("DOWN")))
#         elif ev_type == get_ev_type("KEY") and ev_code == get_key_code("Q") and ev_value == get_key_value("UP"):
#             event_queue.append((t_key-1, ev_type, get_key_code("Z"), get_key_value("DOWN")))
#             event_queue.append((t_key-1, get_ev_type("SYN"), get_syn_code("REPORT"), 0))
#             event_queue.append((t_key, ev_type, get_key_code("LEFTSHIFT"), get_key_value("UP")))
#         else:
#             event_queue.append((t_key,ev_type, ev_code, ev_value))
#             for event in event_queue:
#                 t_key, ev_type, ev_code, ev_value = event
#                 event_out(t_key, ev_type, ev_code, ev_value, args)
#             event_queue = []
#######################################################################
# main: parse commandline parser
#######################################################################
def main():
    parser = argparse.ArgumentParser(
        description="""\
A collection of python scripts to play with evdev events.

version: {}

copyright 2022 Osamu Aoki <osamu@debian.org>

license: GPL 2.0+

See See https://github.com/osamuaoki/{}
""".format(
            "0.1", "osamu-utils"
        ),
    )
    parser.add_argument(
        "-v",
        "--verbose",
        action="count",
        default=0,
        help="Set output to be more verbose",
    )
    parser.add_argument(
        "-q", "--quiet", action="count", default=0, help="Set output to be more quieter"
    )
    parser.add_argument(
        "-c",
        "--command",
        action="store",
        default="T",
        help="Command mode (TextDump, Passthrough, Mangle)",
    )
    parser.add_argument(
        "-m",
        "--no-misc",
        action="store_true",
        default=False,
        help="No mis. events",
    )
    parser.add_argument(
        "-k",
        "--key-only",
        action="store_true",
        default=False,
        help="Only key events",
    )
    parser.add_argument(
        "-t",
        "--time-format",
        action="store",
        default="D",
        help="Time format (abs, this, del)",
    )
    parser.add_argument(
        "-o",
        "--output",
        action="store",
        default="T",
        help="Output format (tsv-csv, yaml)",
    )
    parser.add_argument(
        "-s",
        "--state",
        action="store",
        default="official",
        help="state press/release/repeat indicators (official, utf-8, ascii)",
    )
    args = parser.parse_args()
    if args.state.upper()[0] == "U":  # UTF-8
        args.key_value_string_type = 1
    elif args.state.upper()[0] == "O":  # Official names
        args.key_value_string_type = 0
    else:
        args.key_value_string_type = 2
    #######################################################################
    # Update variables with sanitization
    #######################################################################
    #    CRITICAL 50
    #    ERROR 40
    #    WARNING 30
    #    INFO 20
    #    DEBUG 10
    logging.root.level = 10 * (args.quiet - args.verbose) + 40
    map(args)
    return


#######################################################################
# Test code
#######################################################################
if __name__ == "__main__":
    main()
