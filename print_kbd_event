#!/usr/bin/python3
"""Simple tool for watching what keyboard events are being generated.

Usage: intercept $DEVNODE | python3 print_kbd_event

Do not use -g on intercept -- that will swallow all keyboard input and this
script does not print it out in a way that can be used to keep keyboard input
working.
"""

# This source code was a part of Chorded Keymap,
#          https://gitlab.com/wsha/chorded_keymap
# a plugin for Interception Tools (https://gitlab.com/interception/linux/tools)
# that temporarily remaps the keyboard when a set of keys (a "chord") is
# pressed simultaneously.
#    Copyright (C) 2017 wsha

# The code has been heavily modified to be easy for human to monitor evdev
# device activity.  I am using this as local ~/bin script:
#          https://github.com/osamuaoki/osamu-utils
#    Copyright (C) 2022 Osamu Aoki

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA

import struct
import sys
import time

t0 = int(time.time_ns() / 1000000) - 20  # ms start (20 ms padding)

#      input_event struct format:
#     struct input_event {
#             __kernel_ulong_t __sec;
#             __kernel_ulong_t __usec;
#             __u16 type;
#             __u16 code;
#             __s32 value;
#     };

# This line is taken from print_events.py by wsha
INPUT_EVENT = struct.Struct("llHHI")


def tdel_ms(t_s, t_ns, t0):
    # granularity 1 ms
    return max(0, int((t_s * 1000 + t_ns / 1000 - t0)) / 1000)


EV_TYPE = (
    "SYN",
    "KEY",
    "REL",
    "ABS",
    "MSC",
    "SW",
    "X06",
    "X07",
    "X08",
    "X09",
    "X0A",
    "X0B",
    "X0C",
    "X0D",
    "X0E",
    "X0F",
    "X10",
    "LED",
    "SND",
    "REP",
    "FF",
    "PWR",
    "FF_STATUS",
    "X18",
    "X19",
    "X1A",
    "X1B",
    "X1C",
    "X1D",
    "X1E",
    "MAX",
)

SYN_CODE = ("REPORT", "CONFIG", "MT_REPORT", "DROPPED")

KEY_CODE = (
    "RESERVED",
    "ESC",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9",
    "0",
    "MINUS",
    "EQUAL",
    "BACKSPACE",
    "TAB",
    "Q",
    "W",
    "E",
    "R",
    "T",
    "Y",
    "U",
    "I",
    "O",
    "P",
    "LEFTBRACE",
    "RIGHTBRACE",
    "ENTER",
    "LEFTCTRL",
    "A",
    "S",
    "D",
    "F",
    "G",
    "H",
    "J",
    "K",
    "L",
    "SEMICOLON",
    "APOSTROPHE",
    "GRAVE",
    "LEFTSHIFT",
    "BACKSLASH",
    "Z",
    "X",
    "C",
    "V",
    "B",
    "N",
    "M",
    "COMMA",
    "DOT",
    "SLASH",
    "RIGHTSHIFT",
    "KPASTERISK",
    "LEFTALT",
    "SPACE",
    "CAPSLOCK",
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",
    "F8",
    "F9",
    "F10",
    "NUMLOCK",
    "SCROLLLOCK",
    "KP7",
    "KP8",
    "KP9",
    "KPMINUS",
    "KP4",
    "KP5",
    "KP6",
    "KPPLUS",
    "KP1",
    "KP2",
    "KP3",
    "KP0",
    "KPDOT",
    "KC_84",
    "ZENKAKUHANKAKU",
    "102ND",
    "F11",
    "F12",
    "RO",
    "KATAKANA",
    "HIRAGANA",
    "HENKAN",
    "KATAKANAHIRAGANA",
    "MUHENKAN",
    "KPJPCOMMA",
    "KPENTER",
    "RIGHTCTRL",
    "KPSLASH",
    "SYSRQ",
    "RIGHTALT",
    "LINEFEED",
    "HOME",
    "UP",
    "PAGEUP",
    "LEFT",
    "RIGHT",
    "END",
    "DOWN",
    "PAGEDOWN",
    "INSERT",
    "DELETE",
    "MACRO",
    "MUTE",
    "VOLUMEDOWN",
    "VOLUMEUP",
    "POWER",
    "KPEQUAL",
    "KPPLUSMINUS",
    "PAUSE",
    "SCALE",
    "KPCOMMA",
    "HANGEUL",
    "HANJA",
    "YEN",
    "LEFTMETA",
    "RIGHTMETA",
    "COMPOSE",
)

KEY_VALUE = ("↑", "↓", "→")  # RELEASE, PRESS, REPEAT

# MSC
MSC_CODE = ("SERIAL", "PULSELED", "GESTURE", "RAW", "SCAN", "TIMESTAMP")

tdel_prev = -1

# Trim print out by customizing loop
while True:
    data = sys.stdin.buffer.read(INPUT_EVENT.size)
    (t_s, t_ns, ev_type, ev_code, ev_value) = INPUT_EVENT.unpack(data)
    ev_type_s = EV_TYPE[ev_type]
    tdel_now = tdel_ms(t_s, t_ns, t0)
    if ev_type == 0:  # EV_SYN
        if ev_code < 3:
            ev_code_s = SYN_CODE[ev_code]
        else:
            ev_code_s = "SYN_{:#x}".format(ev_code)
        ev_value_s = "{}".format(ev_value)
    elif ev_type == 1:  # EV_KEY
        if ev_code < 128:
            ev_code_s = KEY_CODE[ev_code]
        elif ev_code < 256:
            ev_code_s = "KC_{}".format(ev_code)
        else:
            ev_code_s = "KC_{:#x}".format(ev_code)
        if ev_value < 3:
            ev_value_s = KEY_VALUE[ev_value]
        else:
            v_value_s = "***INVALID***"
    # If you want to skip printing useless scan code, un-comment
    #    elif ev_type == 4 and ev_code == 4:  # EV_MSC SCAN
    #        continue
    elif ev_type == 4:  # EV_MSC
        if ev_code < 6:
            ev_code_s = MSC_CODE[ev_code]
        else:
            ev_code_s = "MSC{}".format(ev_code)
        ev_value_s = "{:#x}".format(ev_value)
    else:
        ev_code_s = "{}".format(ev_code)
        ev_value_s = "{}".format(ev_value)
    if tdel_now == tdel_prev:
        print(" / ", end="")
    else:
        print("\n", tdel_now, end=": ")
        tdel_prev = tdel_now
    print(ev_type_s, ev_code_s, ev_value_s, end="", flush=True)
