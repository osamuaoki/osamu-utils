#!/usr/bin/python3
# vim:se tw=0 sts=4 ts=4 et ai:
"""
evmk -- keyboard event data tool

Copyright © 2022 Osamu Aoki

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA
"""
# For main
import argparse
import logging

# deb: python3-systemd
from systemd import journal

# import locale
import sys

# from operator import itemgetter

# internal time unit is ms
import time
import struct

# select was not helpful
# import select
import collections

MIN_PYTHON = (3, 9)

if sys.version_info < MIN_PYTHON:
    sys.exit("Python {}.{} or later is required.\n".format(*MIN_PYTHON))

logger = logging.getLogger()
logger.addHandler(journal.JournalHandler())

#######################################################################
# common kbd event data constants and functions
#######################################################################
TAP_TIME = 1000  # ms

EV_TYPE = {
    0: "SYN",
    1: "KEY",
    2: "REL",
    3: "ABS",
    4: "MSC",
    5: "SW",
    17: "LED",
    18: "SND",
    19: "REP",
    20: "FF",
    21: "PWR",
    22: "FF_STATUS",
}

TYPE_SYN = 0
TYPE_KEY = 1
TYPE_MSC = 4
TYPE_LED = 17

SYN_CODE = {0: "REPORT", 1: "CONFIG", 2: "MT_REPORT", 3: "DROPPED"}

SYN_REPORT = 0

KEY_CODE = {
    0: "RESERVED",
    1: "ESC",
    2: "1",
    3: "2",
    4: "3",
    5: "4",
    6: "5",
    7: "6",
    8: "7",
    9: "8",
    10: "9",
    11: "0",
    12: "MINUS",
    13: "EQUAL",
    14: "BACKSPACE",
    15: "TAB",
    16: "Q",
    17: "W",
    18: "E",
    19: "R",
    20: "T",
    21: "Y",
    22: "U",
    23: "I",
    24: "O",
    25: "P",
    26: "LEFTBRACE",
    27: "RIGHTBRACE",
    28: "ENTER",
    29: "LEFTCTRL",
    30: "A",
    31: "S",
    32: "D",
    33: "F",
    34: "G",
    35: "H",
    36: "J",
    37: "K",
    38: "L",
    39: "SEMICOLON",
    40: "APOSTROPHE",
    41: "GRAVE",
    42: "LEFTSHIFT",
    43: "BACKSLASH",
    44: "Z",
    45: "X",
    46: "C",
    47: "V",
    48: "B",
    49: "N",
    50: "M",
    51: "COMMA",
    52: "DOT",
    53: "SLASH",
    54: "RIGHTSHIFT",
    55: "KPASTERISK",
    56: "LEFTALT",
    57: "SPACE",
    58: "CAPSLOCK",
    59: "F1",
    60: "F2",
    61: "F3",
    62: "F4",
    63: "F5",
    64: "F6",
    65: "F7",
    66: "F8",
    67: "F9",
    68: "F10",
    69: "NUMLOCK",
    70: "SCROLLLOCK",
    71: "KP7",
    72: "KP8",
    73: "KP9",
    74: "KPMINUS",
    75: "KP4",
    76: "KP5",
    77: "KP6",
    78: "KPPLUS",
    79: "KP1",
    80: "KP2",
    81: "KP3",
    82: "KP0",
    83: "KPDOT",
    # 84 skipped with reason
    85: "ZENKAKUHANKAKU",
    86: "102ND",
    87: "F11",
    88: "F12",
    89: "RO",
    90: "KATAKANA",
    91: "HIRAGANA",
    92: "HENKAN",
    93: "KATAKANAHIRAGANA",
    94: "MUHENKAN",
    95: "KPJPCOMMA",
    96: "KPENTER",
    97: "RIGHTCTRL",
    98: "KPSLASH",
    99: "SYSRQ",
    100: "RIGHTALT",
    101: "LINEFEED",
    102: "HOME",
    103: "UP",
    104: "PAGEUP",
    105: "LEFT",
    106: "RIGHT",
    107: "END",
    108: "DOWN",
    109: "PAGEDOWN",
    110: "INSERT",
    111: "DELETE",
    112: "MACRO",
    113: "MUTE",
    114: "VOLUMEDOWN",
    115: "VOLUMEUP",
    116: "POWER",
    117: "KPEQUAL",
    118: "KPPLUSMINUS",
    119: "PAUSE",
    120: "SCALE",
    121: "KPCOMMA",
    122: "HANGEUL",
    123: "HANJA",
    124: "YEN",
    125: "LEFTMETA",
    126: "RIGHTMETA",
    127: "COMPOSE",
    127: "COMPOSE",
    143: "WAKEUP",
}

KC_WAKEUP = 143

KC_LEFT_SHIFT = 42
KC_LEFT_CTRL = 29
KC_LEFT_ALT = 56
KC_LEFT_META = 125
KC_RIGHT_SHIFT = 54
KC_RIGHT_CTRL = 97
KC_RIGHT_ALT = 100
KC_RIGHT_META = 126

MODKEYS = [
    KC_LEFT_SHIFT,
    KC_LEFT_CTRL,
    KC_LEFT_ALT,
    KC_LEFT_META,
    KC_RIGHT_SHIFT,
    KC_RIGHT_CTRL,
    KC_RIGHT_ALT,
    KC_RIGHT_META,
]

MOD_LAYER0 = 0
MOD_LAYER1 = 1
MOD_LAYER2 = 2
MOD_LAYER3 = 3
MOD_LAYER4 = 4
MOD_LAYER5 = 5
MOD_LAYER6 = 6
MOD_LAYER7 = 7

KEY_UP = 0
KEY_DN = 1
KEY_RP = 2

KEY_VALS = {
    KEY_UP: ["↑", "UP", "RELEASE"],
    KEY_DN: ["↓", "DN", "PRESS"],
    KEY_RP: ["→", "RP", "REPEAT"],
}

MSC_CODE = {
    0: "SERIAL",
    1: "PULSELED",
    2: "GESTURE",
    3: "RAW",
    4: "SCAN",
    5: "TIMESTAMP",
}

MSC_SCAN = 4


def read_keymap(fn="keymap.csv"):
    with open(fn) as file:
        n = file.readline().split(",")
        M = int(n[0], 0)  # 128
        N = int(n[1], 0)  # 3
        map = []
        for i in range(M):
            l = file.readline()
            n = l.split(",")
            map.append([])
            for j in range(N):
                map[i].append(int(n[j + 1], 0))
        return (M, N, map)


# In order to simplify print/log formatting, use -1 as None for positive
# integer event data
NONE = -1
# Dual function key flag
TBDKEY = -1  # -1: Need additional following key inputs to determine
BASEKEY = 0  #  0: Use low 16 bits (base code)
MODKEY = 1  #  1: Use as mod key / layer key
#  3: Use low 16 bits (tap) -- double tap (LATER)
#  4: Use low 16 bits (tap) for repeat -- double tap and hold (LATER)

DFK = {
    TBDKEY: "TBD",
    BASEKEY: "BASE",
    MODKEY: "MOD",
}


class key_event_grp:
    # Keyboard event class
    def __init__(self):
        self.ev_t_s = NONE  # the last data time (s)
        self.ev_t_us = NONE  # the last data time (us)
        self.ev_type = NONE  # the last data type MSC, KEY, SYN, LED, ...
        self.ev_code = KC_WAKEUP  # the last key code (mapped to new value)
        self.ev_code_orig = NONE  # the last key code (unmodified original value)
        self.ev_value = NONE  # the last key state 0, 1, 2
        self.time_ms = NONE  # the last data time (us)
        self.grp = False  # event grouped or not
        self.grp_type = NONE  # grouped data type
        self.grp_code = KC_WAKEUP  # grouped key code
        self.grp_code_orig = NONE  # que1key.grp_code (before mapping)
        self.grp_value = NONE  # grouped key state 0, 1, 2
        self.grp_scan = NONE  # grouped scan code
        self.grp_ready = False
        self.grp_error = False
        self.grp_map = None
        self.grp_dfk = TBDKEY  # see above
        return

    def update(self, ev_t_s, ev_t_us, ev_type, ev_code, ev_value, args):
        self.ev_type = ev_type
        self.ev_code = ev_code
        self.ev_value = ev_value
        if args.group:
            if self.ev_t_s == NONE and self.ev_t_us == NONE:
                self.ev_t_s = ev_t_s
                self.ev_t_us = ev_t_us
                self.time_ms = int(self.ev_t_s * 1000 + self.ev_t_us / 1000)
            elif self.ev_t_s == ev_t_s and self.ev_t_us == ev_t_us:
                pass
            else:
                logger.warning(
                    "I: TYPE={:02x} CODE={:02x} VALUE={:02x}: skewed timing ev_t_us: old={}.{:09d} new={}.{:09d}".format(
                        ev_type, self.ev_t_s, self.ev_t_us, ev_t_s, ev_t_us
                    )
                )
            if ev_type == TYPE_MSC and ev_code == MSC_SCAN:
                self.grp_scan = ev_value
                self.grp_ready = False
            elif ev_type == TYPE_LED:
                self.grp_type = ev_type
                self.grp_code = ev_code
                self.grp_value = ev_value
                self.grp_ready = False
            elif ev_type == TYPE_KEY:  # KEY (key code and value report)
                self.grp_type = ev_type
                self.grp_code = ev_code
                self.grp_code_orig = ev_code
                self.grp_value = ev_value
                self.grp_ready = False
            elif ev_type == TYPE_SYN and ev_code == SYN_REPORT:
                if (
                    self.grp_type == TYPE_KEY
                    and ev_value == KEY_DN
                    and self.grp_scan == NONE
                ):  # KEY
                    self.grp = True
                    self.grp_ready = True
                elif (
                    self.grp_type == TYPE_KEY
                    and ev_value == KEY_UP
                    and self.grp_scan != NONE
                ):
                    self.grp = True
                    self.grp_ready = True
                elif self.grp_type == TYPE_LED:
                    self.grp = True
                    self.grp_ready = True
                else:  # NON STANDARD SYN
                    self.grp = False
                    self.grp_ready = True
                    self.grp_error = True
            else:  # NON STANDARD NON-SYN
                self.grp = False
                self.grp_ready = True
                self.grp_error = True
        else:  # No grouping
            self.ev_t_s = ev_t_s
            self.ev_t_us = ev_t_us
            self.grp = False
            self.grp_ready = True

    def del_time_ms(self, time_ms_old):
        return self.time_ms - time_ms_old

    def get_timestamp_string(self, time_ms_old, args):
        if args.timestamp:
            if args.delta:
                return "{:06d} ".format(self.del_time_ms(time_ms_old))
            else:
                return "{:016d} ".format(self.time_ms)
        else:
            return ""

    def get_grp_type_string(self):
        return "{:6s}".format(
            EV_TYPE.get(self.grp_type, "TYPE_{:02x}".format(self.grp_type))
        )

    def get_grp_code_string(self):
        return "{:10s} {:02x}".format(
            KEY_CODE.get(self.grp_code & 0x3FF, "*****"),
            self.grp_code,
        )

    def get_grp_value_string(self, args):
        return KEY_VALS.get(self.grp_value, ["{:02x}".format(self.grp_value)] * 3)[
            args.key_value_string_type
        ]

    def get_grp_code_hex_string(self):
        return "{:02x}".format(self.grp_code)

    def get_grp_value_hex_string(self):
        return "{:02x}".format(self.grp_value)

    def get_grp_scan_string(self):
        return "{:02x}".format(self.grp_scan)

    def get_ev_type_string(self):
        return EV_TYPE.get(self.ev_type, "TYPE_{:02x}".format(self.ev_type))

    def get_msc_code_string(self):
        return MSC_CODE.get(self.ev_code, "MSC_x{:02x}".format(self.ev_code))

    def get_msc_value_string(self):
        return "{:02x}".format(self.ev_value)

    def get_key_code_string(self):
        return "{:10s} {:02x}".format(
            KEY_CODE.get(self.ev_code & 0x3FF, "*****"), self.ev_code
        )

    def get_key_value_string(self, args):
        return KEY_VALS.get(self.ev_value, ["{:02x}".format(self.ev_value)] * 3)[
            args.key_value_string_type
        ]

    def get_syn_code_string(self):
        return SYN_CODE.get(self.ev_code, "SYN_{:02x}".format(self.ev__code))

    def get_syn_value_string(self):
        return "{:02x}".format(self.ev_value)

    def get_ev_code_string(self):
        return "{:02x}".format(self.ev_code)

    def get_ev_value_string(self):
        return "{:02x}".format(self.ev_value)

    def get_dfk_string(self):
        return DFK.get(self.grp_dfk, "DFK_{:02x}".format(self.grp_dfk))

    def report_grp_error(self, id):
        # single ev data with some data for grp
        logger.warning(
            "{}: unexpected ev type={:02x} code={:02x} value={:02x} for group type={:02x} code={:02x} value={:02x} scan={:02x}".format(
                id,
                self.ev_type,
                self.ev_code,
                self.ev_value,
                self.grp_type,
                self.grp_code,
                self.grp_value,
                self.grp_scan,
            )
        )

    def report_grp3_ev(self, id, time_ms_old, args):
        if self.grp_type == TYPE_KEY:
            logger.info(
                "{}: {}{} grp3 {} {} scan={} dfk={}".format(
                    id,
                    self.get_timestamp_string(time_ms_old, args),
                    self.get_grp_type_string(),
                    self.get_grp_code_string(),
                    self.get_grp_value_string(args),
                    self.get_grp_scan_string(),
                    self.get_dfk_string(),
                )
            )
        else:
            logger.info(
                "{}: {}{} grp3_no_key code={} value={} scan={} dfk={}".format(
                    id,
                    self.get_timestamp_string(time_ms_old, args),
                    self.get_grp_type_string(),
                    self.get_grp_code_hex_string(),
                    self.get_grp_value_hex_string(),
                    self.get_grp_scan_string(),
                    self.get_dfk_string(),
                )
            )

    def report_grp2_ev(self, id, time_ms_old, args):
        if self.grp_type == TYPE_KEY:
            logger.info(
                "{}: {}{} grp2 {} {} dfk={}".format(
                    id,
                    self.get_timestamp_string(time_ms_old, args),
                    self.get_grp_type_string(),
                    self.get_grp_code_string(),
                    self.get_grp_value_string(args),
                    self.get_dfk_string(),
                )
            )
        else:
            logger.info(
                "{}: {}{} grp2_no_key code={} value={} dfk={}".format(
                    id,
                    self.get_timestamp_string(time_ms_old, args),
                    self.get_grp_type_string(),
                    self.get_grp_code_hex_string(),
                    self.get_grp_value_hex_string(),
                    self.get_dfk_string(),
                )
            )

    def report_single_ev(self, id, time_ms_old, args):
        if self.ev_type == TYPE_MSC:
            logger.info(
                "{}: {}{} single {} {}".format(
                    id,
                    self.get_timestamp_string(time_ms_old, args),
                    self.get_ev_type_string(),
                    self.get_msc_code_string(),
                    self.get_msc_value_string(),
                )
            )
        elif self.ev_type == TYPE_KEY:
            logger.info(
                "{}: {}{} single {} {}".format(
                    id,
                    self.get_timestamp_string(time_ms_old, args),
                    self.get_ev_type_string(),
                    self.get_key_code_string(),
                    self.get_key_value_string(args),
                )
            )
        elif self.ev_type == TYPE_SYN:
            logger.info(
                "{}: {}{} single {} {}".format(
                    id,
                    self.get_timestamp_string(time_ms_old, args),
                    self.get_ev_type_string(),
                    self.get_syn_code_string(),
                    self.get_syn_value_string(),
                )
            )
        else:  # others
            logger.info(
                "{}: {}{} single ev_code={} ev_value={}".format(
                    id,
                    self.get_timestamp_string(time_ms_old, args),
                    self.get_ev_type_string(),
                    self.get_ev_code_string(),
                    self.get_ev_value_string(),
                )
            )

    def report_ev(self, id, time_ms_old, args):
        if self.grp and self.grp_scan != NONE:
            self.report_grp3_ev(id, time_ms_old, args)
        elif self.grp:  #  key.grp_scan is NONE:
            self.report_grp2_ev(id, time_ms_old, args)
        else:  # key.grp==False
            if self.grp_error:
                self.report_grp_error(id)
            self.report_single_ev("I", time_ms_old, args)


def report_que(que, id, layer, time_ms_old, args):
    for i in range(len(que)):
        quekey = que[i]
        idx = "{} {}/{} {}".format(id, i, len(que), layer)
        quekey.report_ev(idx, time_ms_old, args)


# DFK types
DFK_NO = False
DFK_YES = True


class dfk_state:
    def __init__(self, type):
        self.type = type
        self.last_code = NONE  # prevent release/repeat after release
        self.last_dfk = BASEKEY

    def update(self, last_code, last_dfk):
        self.last_code = last_code
        self.last_dfk = last_dfk


#######################################################################
# sub-commands
#######################################################################

EV = struct.Struct("llHHI")
# read event data from stdin and output to stdout
def read_and_write(args):
    que1 = collections.deque()
    que2 = collections.deque()
    (M, N, map) = read_keymap()
    layer = 0
    key = key_event_grp()
    dfk_state_matrix = []  # Store dfk_state for each grp_code_orig
    for m in range(M):
        type = DFK_NO
        for n in range(N):
            if map[m][n] & 0xFFFF000 != 0:
                type = DFK_YES
        dfk_state_item = dfk_state(type)
        dfk_state_matrix.append(dfk_state_item)
    # time_ms in ms (real) -- TAP_TIME/2 ms offset
    time_ms_old_in = int((time.time_ns() / 1000000) - (TAP_TIME / 2))
    time_ms_old_out = time_ms_old_in
    count = 0
    while True:
        # use of select.select didn't work well
        #     timeout = 0.2  # timeout 200 ms later
        #     rlist, _, _ = select.select([sys.stdin], [], [], timeout)
        #     if rlist:  -- this doesn't read released key event
        #
        #####################################################################
        # read event data from stdin to que1
        #####################################################################
        data = sys.stdin.buffer.read(EV.size)
        (ev_t_s, ev_t_us, ev_type, ev_code, ev_value) = EV.unpack(data)
        # The following sets .grp_ready until SYN for grouped processing
        key.update(ev_t_s, ev_t_us, ev_type, ev_code, ev_value, args)
        # make a event group for each meaningful key move
        #   .grp_code=<key code>, .grp_value=<key state>, .grp_scan=<scan code>
        if not key.grp_ready:
            #  group data until SYN w/o calling key = key_event_grp()
            continue
        # Fool initial release/repeat key capturing
        count += 1
        if count == 1:
            if key.grp and key.grp_value != KEY_DN:
                dfk_state_matrix[key.grp_code_orig].last_code = key.grp_code_orig
        else:
            count = 2
        #####################################################################
        # report input event
        #####################################################################
        if "1" in args.section.upper():
            key.report_ev("P1", time_ms_old_in, args)
        #####################################################################
        # process group to set up initial internal values
        #####################################################################
        if key.grp and key.grp_type == TYPE_KEY and key.grp_code_orig < M:
            # mappable range KEY
            key.grp_map = map[key.grp_code_orig]
            if dfk_state_matrix[key.grp_code_orig].type == DFK_YES:
                key.dfk = TBDKEY
            else:
                key.dfk = BASEKEY
        # else:  # grouped high KEY such as WAKEUP or other type (LED) and single
        #     key.grp_map = [key.grp_code_orig] * N  # -- probably redundant
        #     key.dfk = BASEKEY  # dual function key state tap
        que1.append(key)
        #####################################################################
        # monitor que1 data to be processed
        #####################################################################
        if "2" in args.section.upper():
            report_que(que1, "P2", layer, time_ms_old_in, args)
        #####################################################################
        # process que1 for key conversion with layer
        #####################################################################

        while len(que1) > 0:
            #################################################################
            # KEY conversion for grp
            #################################################################
            if (
                que1[0].grp
                and que1[0].grp_type == TYPE_KEY
                and que1[0].grp_code_orig < M
            ):
                que1[0].grp_code = que1[0].grp_map[layer]
            if (
                que1[0].grp
                and que1[0].grp_type == TYPE_KEY
                and que1[0].grp_code_orig < M
                and que1[0].grp_dfk == TBDKEY
            ):
                if que1[0].grp_value == KEY_DN:
                    # let's check followings inputs
                    tapped_keys = {}
                    for i in range(1, len(que1), 1):
                        del_time_ms_i = que1[i].del_time_ms(que1[0].time_ms)
                        if del_time_ms_i < TAP_TIME:
                            if (
                                que1[i].grp_value == KEY_DN
                                and que1[i].grp_code_orig != que1[0].grp_code_orig
                            ):
                                tapped_keys[i] = que1[i].grp_code_orig
                            if (
                                que1[i].grp_value != KEY_DN
                                and que1[i].grp_code_orig != que1[0].grp_code_orig
                                and que1[i].grp_code_orig in tapped_keys.values()
                            ):
                                # other KEY tapped
                                for j in range(0, i):
                                    if que1[j].grp_code_orig == que1[0].grp_code_orig:
                                        que1[j].grp_dfk = MODKEY
                                if "3" in args.section.upper():
                                    que1[0].report_ev(
                                        "P3 MOD(external)", time_ms_old_in, args
                                    )
                            if (
                                que1[i].grp_value == KEY_UP
                                and que1[i].grp_code_orig == que1[0].grp_code_orig
                            ):
                                for j in range(0, i + 1):
                                    if que1[j].grp_code_orig == que1[0].grp_code_orig:
                                        que1[j].grp_dfk = BASEKEY
                                if "3" in args.section.upper():
                                    que1[0].report_ev(
                                        "P3 TAP(time)", time_ms_old_in, args
                                    )
                                break
                        else:
                            for j in range(0, i + 1):
                                if que1[j].grp_code_orig == que1[0].grp_code_orig:
                                    que1[j].grp_dfk = MODKEY
                            if "3" in args.section.upper():
                                que1[0].report_ev("P3 MOD(time)", time_ms_old_in, args)
                            break
                    dfk_state_matrix[que1[0].grp_code_orig].update(
                        que1[0].grp_code, que1[0].grp_dfk
                    )
                elif que1[0].grp_value == KEY_UP:
                    que1[0].grp_dfk = dfk_state_matrix[que1[0].grp_code_orig].last_dfk
                    que1[0].grp_code = dfk_state_matrix[que1[0].grp_code_orig].last_code
                else:  # elif que1[0].grp_value == KEY_RP:
                    que1[0].grp_dfk = dfk_state_matrix[que1[0].grp_code_orig].last_dfk
                    que1[0].grp_code = dfk_state_matrix[que1[0].grp_code_orig].last_code
            #################################################################
            # Report que1
            #################################################################
            if "4" in args.section.upper():
                report_que(que1, "P4", layer, time_ms_old_in, args)
            if "5" in args.section.upper():
                que1[0].report_ev("P5", time_ms_old_in, args)
            #################################################################
            # Pass from que1 to que2
            #################################################################
            if (
                que1[0].grp
                and que1[0].grp_type == TYPE_KEY
                and que1[0].grp_code_orig < M
            ):
                if que1[0].grp_dfk == BASEKEY:
                    # logger.info("BASE: len={} code={:02x} layer= {} dfk={}".format(len(que1), que1[0].grp_code, layer, que1[0].grp_dfk))
                    que1key = que1.popleft()
                    if que1key.grp:
                        # Drop modifier data for grouped keys
                        que1key.grp_code = que1key.grp_code & 0x3FF
                    if que1key.grp_value == KEY_DN:
                        dfk_state_matrix[que1key.grp_code_orig].update(
                            que1key.grp_code, BASEKEY
                        )
                        que2.append(que1key)
                    elif que1key.grp_value == KEY_RP:
                        dfk_state_matrix[que1key.grp_code_orig].update(
                            que1key.grp_code, BASEKEY
                        )
                        if que1key.grp_code not in MODKEYS:
                            que2.append(que1key)
                    else:  # que1key.grp_value == KEY_UP:
                        dfk_state_matrix[que1key.grp_code_orig].update(
                            que1key.grp_code, TBDKEY
                        )
                        que2.append(que1key)
                elif que1[0].grp_dfk == MODKEY:  # only .grp=True
                    que1key = que1.popleft()
                    mod = que1key.grp_code >> 16
                    if que1key.grp_value == KEY_DN:
                        dfk_state_matrix[que1key.grp_code_orig].update(
                            que1key.grp_code, MODKEY
                        )
                    elif que1key.grp_value == KEY_RP:
                        pass
                    else:  # que1key.grp_value == KEY_UP:
                        dfk_state_matrix[que1key.grp_code_orig].update(
                            que1key.grp_code, TBDKEY
                        )
                    # modifiers (mod low bits) are not mutually exclusive
                    if mod & (1 << 0):
                        que1key.grp_code = KC_LEFT_SHIFT
                        if que1key.grp_value != KEY_RP:
                            que2.append(que1key)
                    if mod & (1 << 1):
                        que1key.grp_code = KC_LEFT_CTRL
                        if que1key.grp_value != KEY_RP:
                            que2.append(que1key)
                    if mod & (1 << 2):
                        que1key.grp_code = KC_LEFT_ALT
                        if que1key.grp_value != KEY_RP:
                            que2.append(que1key)
                    if mod & (1 << 3):
                        que1key.grp_code = KC_LEFT_META
                        if que1key.grp_value != KEY_RP:
                            que2.append(que1key)
                    if mod & (1 << 4):
                        que1key.grp_code = KC_RIGHT_SHIFT
                        if que1key.grp_value != KEY_RP:
                            que2.append(que1key)
                    if mod & (1 << 5):
                        que1key.grp_code = KC_RIGHT_CTRL
                        if que1key.grp_value != KEY_RP:
                            que2.append(que1key)
                    if mod & (1 << 6):
                        que1key.grp_code = KC_RIGHT_ALT
                        if que1key.grp_value != KEY_RP:
                            que2.append(que1key)
                    if mod & (1 << 7):
                        que1key.grp_code = KC_RIGHT_META
                        if que1key.grp_value != KEY_RP:
                            que2.append(que1key)
                    # layers (mod low bits) are mutually exclusive
                    if mod & 0xFF00:  # layer
                        if que1key.grp_value == KEY_UP:  # Released
                            layer = MOD_LAYER0
                        elif que1key.grp_value == KEY_DN:  # Pressed
                            if mod & (1 << 8):
                                layer = MOD_LAYER0
                            elif mod & (1 << 9):
                                layer = MOD_LAYER1
                            elif mod & (1 << 10):
                                layer = MOD_LAYER2
                            elif mod & (1 << 11):
                                layer = MOD_LAYER3
                            elif mod & (1 << 12):
                                layer = MOD_LAYER4
                            elif mod & (1 << 13):
                                layer = MOD_LAYER5
                            elif mod & (1 << 14):
                                layer = MOD_LAYER6
                            else:  # mod & (1 << 15):
                                layer = MOD_LAYER7
                            if layer >= N:
                                layer = N - 1  # force override
                            # logger.info("M: layer changed to {}".format(layer))
                        else:  # Repeat
                            pass  # NOP
                else:  # que1[0].grp_dfk == TBDPKEY
                    # no que1.popleft()
                    break  # Don't process uncertain keys -> read-in more
            else:  # single, LED, high-bit (WAKEUP)
                que1key = que1.popleft()
                que2.append(que1key)
        # end of while loop for que1
        #####################################################################
        # outut que2
        #####################################################################
        while len(que2) != 0:
            outkey = que2.popleft()
            if "9" in args.section.upper():
                outkey.report_ev("P9", time_ms_old_out, args)
            if outkey.grp:
                if outkey.grp_scan != NONE:
                    if not args.monitor:
                        sys.stdout.buffer.write(
                            EV.pack(
                                outkey.ev_t_s, outkey.ev_t_us, 0, 0, outkey.grp_scan
                            )
                        )
                        sys.stdout.buffer.write(
                            EV.pack(
                                outkey.ev_t_s,
                                outkey.ev_t_us,
                                1,
                                outkey.grp_code,
                                outkey.grp_value,
                            )
                        )
                        sys.stdout.buffer.write(
                            EV.pack(outkey.ev_t_s, outkey.ev_t_us, 4, 4, 0)
                        )
                else:
                    if not args.monitor:
                        sys.stdout.buffer.write(
                            EV.pack(
                                outkey.ev_t_s,
                                outkey.ev_t_us,
                                1,
                                outkey.grp_code,
                                outkey.grp_value,
                            )
                        )
                        sys.stdout.buffer.write(
                            EV.pack(outkey.ev_t_s, outkey.ev_t_us, 4, 4, 1)
                        )
            else:  # single
                if not args.monitor:
                    sys.stdout.buffer.write(
                        EV.pack(
                            outkey.ev_t_s,
                            outkey.ev_t_us,
                            outkey.ev_type,
                            outkey.ev_code,
                            outkey.ev_value,
                        )
                    )
            time_ms_old_out = outkey.time_ms
        # Seemingly good flush() causes infinite repeat-key problem
        # sys.stdout.buffer.flush()
        del key
        key = key_event_grp()
    # LOOPEND


#######################################################################
# main: parse commandline parser
#######################################################################
def main():
    parser = argparse.ArgumentParser(
        description="""\
A collection of python scripts to play with evdev events.

version: {}

copyright 2022 Osamu Aoki <osamu@debian.org>

license: GPL 2.0+

See See https://github.com/osamuaoki/{}
""".format(
            "0.1", "evmk"
        ),
    )
    parser.add_argument(
        "-t",
        "--timestamp",
        action="store_true",
        default=False,
        help="with timestamp",
    )
    parser.add_argument(
        "-d",
        "--delta",
        action="store_true",
        default=False,
        help="time as delta",
    )
    parser.add_argument(
        "-v",
        "--value",
        action="store",
        default="utf-8",
        metavar="[u|a|o]",
        help="key state value for log (default=u for ↑ ↓ →)",
    )
    parser.add_argument(
        "-g",
        "--group",
        action="store_true",
        default=False,
        help="group by event grp ending with SYN",
    )
    parser.add_argument(
        "-m",
        "--monitor",
        action="store_true",
        default=False,
        help="monitor only (no stdout)",
    )
    parser.add_argument(
        "-s",
        "--section",
        action="store",
        default="9",
        help="section to activate log: [1|2|3|4|5|9]",
    )
    parser.add_argument(
        "-l",
        "--log",
        action="store",
        default="WARNING",
        help="set logging level (default=WARNING)",
    )
    args = parser.parse_args()
    #######################################################################
    # Update variables with sanitization
    #######################################################################
    if args.log == "":
        logger.setLevel(logging.INFO)
    elif args.log[0].upper() == "D":
        logger.setLevel(logging.DEBUG)
    elif args.log[0].upper() == "I":
        logger.setLevel(logging.INFO)
    elif args.log[0].upper() == "W":
        logger.setLevel(logging.WARNING)
    elif args.log[0].upper() == "E":
        logger.setLevel(logging.ERROR)
    else:
        logger.setLevel(logging.CRITICAL)
    args = parser.parse_args()
    if args.value.upper()[0] == "U":  # UTF-8
        args.key_value_string_type = 0
    elif args.value.upper()[0] == "A":  # Single ASCII
        args.key_value_string_type = 1
    else:
        args.key_value_string_type = 2
    read_and_write(args)


#######################################################################
# Test code
#######################################################################
if __name__ == "__main__":
    main()
